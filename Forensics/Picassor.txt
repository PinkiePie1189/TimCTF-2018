Problem:Attendance
Solver(s):JunkWub ?????????#7357

After many tries of finding hidden files in the given file, we gave up and went back to the drawing board to find a new idea. We noticed that the first part of the file seemed oddly regular and arranged, so we supposed it might be a codified regular file. After checking the JPEG file structure, we noticed that it was pretty similar to our file, so we started noting down the changes between our file and a normal JPEG file. Thus, we made a small tabel with Regular JPEG Characters vs. our file's JPEG Characters. (Regular JPEG Characters meaning file headers and other chars that are obligatory present at various positions in every JPEG). It couldn't be a direct conversion between characters, because FF becomes 54, for example. So we'd have to find the more complex codification that the file was using. After various tries, we noticed that there are indeed direct transformations for hex digits, but the transformation table depends on the position of the digit. For example, the F always becomes 5 if it's the first digit in a byte represented in hex, and 4 if it's the second digit. So, we made two tables, one for transformations made for first digits, and another one for transformations made for the second digits. After some deductions we started to complete the tables. For example, if we saw that A is 0, and 0 is A, and that 7 is E and E is 7, we can presume that the table is reversible, effectively reducing the amount of guesses that need to be made by half. After other deductions like filling in a bit obvious holes like 4 _ 6, we finished the tables. We were not 100% certain that they'd be correct, but they were the most plausible ones. Then, we switched to our trusty CodeBlocks IDE and started writing a small C++ program that'd open the file byte by byte, extracting each unsigned character as it parsed it. We passed the characters through a function that'd return the equivalent of the given character judging by the values of our tables, and we'd print the result out, byte by byte. After some bugfixing and finally figuring out how to properly read byte-by-byte in C++, we were able to generate a decoded JPEG file, that had the key written on the picture!